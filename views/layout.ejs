<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= typeof title !== 'undefined' ? title + ' - ' : '' %>Infrastructure Diagrams</title>
  <link rel="stylesheet" href="/css/style.css">
  <% if (typeof extraHead !== 'undefined') { %><%- extraHead %><% } %>
</head>
<body>
  <% if (typeof showNav === 'undefined' || showNav) { %>
  <nav class="navbar">
    <div class="nav-brand">
      <a href="/">Infrastructure Diagrams</a>
    </div>
    <div class="nav-links">
      <a href="/" class="<%= typeof page !== 'undefined' && page === 'dashboard' ? 'active' : '' %>">Dashboard</a>
      <a href="/wave" class="<%= typeof page !== 'undefined' && page === 'wave' ? 'active' : '' %>">
        Wave Sessions
        <span id="queue-badge" class="nav-badge" style="display: none;">0</span>
      </a>
      <a href="/logout" class="nav-logout">Logout</a>
    </div>
  </nav>
  <% } %>

  <main class="container">
    <%- body %>
  </main>

  <% if (typeof extraScripts !== 'undefined') { %><%- extraScripts %><% } %>

  <!-- Toast notification container -->
  <div id="toast-container"></div>

  <!-- Global queue polling and toast notifications -->
  <script>
  (function() {
    const POLL_INTERVAL = 5000; // 5 seconds
    let lastCompletedIds = new Set();
    let lastFailedIds = new Set();
    let initialized = false;

    // Show a toast notification
    function showToast(message, type, link) {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'toast toast-' + type;

      if (link) {
        toast.innerHTML = '<a href="' + link + '">' + message + '</a>';
      } else {
        toast.textContent = message;
      }

      // Add close button
      const closeBtn = document.createElement('button');
      closeBtn.className = 'toast-close';
      closeBtn.innerHTML = '&times;';
      closeBtn.onclick = function() { toast.remove(); };
      toast.appendChild(closeBtn);

      container.appendChild(toast);

      // Auto-dismiss after 5 seconds
      setTimeout(function() {
        toast.classList.add('toast-fade');
        setTimeout(function() { toast.remove(); }, 300);
      }, 5000);
    }

    // Update the queue badge in nav
    function updateBadge(count) {
      const badge = document.getElementById('queue-badge');
      if (badge) {
        if (count > 0) {
          badge.textContent = count;
          badge.style.display = 'inline-block';
        } else {
          badge.style.display = 'none';
        }
      }
    }

    // Poll for queue status
    async function pollQueueStatus() {
      try {
        const response = await fetch('/api/queue/status');
        if (!response.ok) return;

        const status = await response.json();

        // Update badge with pending + processing count
        const activeCount = status.pending + (status.processing ? 1 : 0);
        updateBadge(activeCount);

        // Check for newly completed jobs (show toast)
        if (status.recentCompleted && status.recentCompleted.length > 0) {
          for (const job of status.recentCompleted) {
            if (!lastCompletedIds.has(job.id) && initialized) {
              lastCompletedIds.add(job.id);
              const link = job.customer_id ? '/customer/' + job.customer_id : null;
              showToast('Completed: ' + (job.result_summary || job.title || 'Session processed'), 'completed', link);
            } else if (!initialized) {
              lastCompletedIds.add(job.id);
            }
          }
        }

        // Check for failed jobs
        if (status.recentCompleted) {
          for (const job of status.recentCompleted) {
            if (job.status === 'failed' && !lastFailedIds.has(job.id) && initialized) {
              lastFailedIds.add(job.id);
              showToast('Failed: ' + (job.title || 'Session') + ' - ' + (job.error || 'Unknown error'), 'failed');
            } else if (!initialized && job.status === 'failed') {
              lastFailedIds.add(job.id);
            }
          }
        }

        initialized = true;
      } catch (err) {
        // Silently fail - don't spam errors
      }
    }

    // Start polling when page loads
    document.addEventListener('DOMContentLoaded', function() {
      pollQueueStatus(); // Initial poll
      setInterval(pollQueueStatus, POLL_INTERVAL);
    });
  })();
  </script>
</body>
</html>
